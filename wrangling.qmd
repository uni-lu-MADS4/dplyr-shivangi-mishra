---
title: "Data wrangling"
author: "Shivangi Mishra"
date: "2025-10-13"
output: html_document
editor: source
---




## Part one - Wrangling

This tutorial will allow you to explore `dplyr` functionality based on the previous lecture. Every question can be answered with a combination of `|>` pipes. You should refrain from using temporary variables and statements outside of the range of the tidyverse.  

The first part does not require joins or pivots.

### Import the [data from the website](https://biostat2.uni.lu/practicals/data/judgments.tsv). 
Assign to the name `judgments` and correct the column types where needed.

```{r}
library(tidyverse)
judge_url <- "https://biostat2.uni.lu/practicals/data/judgments.tsv"
judgments <- readr::read_tsv(judge_url)
problems(judgments)
# https://dataverse.nl/api/access/datafile/11863
#"https://biostat2.uni.lu/practicals/data/judgments.tsv")
```
```{r}
spec(judgments)

```
```{r}
problems(judgments)
```



### Use `glimpse()` to identify columns and column types.

What are the dimensions of the data set.
```{r}
#glimpse(judgments)
judgments |>
  group_by(condition, gender) |> 
  summarise(n = n()) -> n_part

slice_head(n_part, n = 1) 
```


### Exercise 1 

You can combine the following tasks into a single statement.

#### Select columns
Select `gender`, `subject`, `age` and referring to the `STAI` questionnaire.

```{r}


#problems()

select(judgments,gender,age,subject,starts_with("STAI"))

#jud2 <- readr::read_delim("https://biostat2.uni.lu/practicals/data/judgments.tsv",
 #            col_types = cols(start_date = col_date(),
 #                             end_date = col_date()))
#
#jud2
#problems()

#jud2 <- readr::read_delim("https://biostat2.uni.lu/practicals/data/judgments.tsv",
 #            col_types = 
#               cols(start_date = col_date(format = "%d/%m/%Y"),
#                    end_date = col_date(format =  "%d/%m/%Y"),
#                    finished = "f",
#                    condition = "f",
#                    gender = "f",
#                    logbook = "c", 
#                    exclude = "f",
#                    moral_judgment = "d",
#                    moral_judgment_disgust = "d",
#                    moral_judgment_non_disgust = "d",
#                    .default = col_integer()))
#
#jud2
```


#### Select all subjects with `STAI_pre` greater than 65 and `STAI_post` greater than 40

```{r}
select(judgments, subject, starts_with("stai_")) |> 
   filter(STAI_pre>65 & STAI_post<40)
```
### Find rows with missing data in both mood columns are missing
```{r}


judgments |> 
  filter(if_all(starts_with("Mood"),is.na)) |> 
  select(subject,starts_with("Mood"))
#or
select(judgments,subject,starts_with("Mood")) |> 
   filter(if_all(starts_with("Mood"),is.na)) 
  

 
```
###Retrieve all subjects younger than 20 which are in the stress group. The column for the group is condition.
```{r}
judgments |> 
select(age,subject,condition) |> 
filter(age<20,condition=="stress")
```
#### Sort the observations by `STAI_pre` so that the subject with the highest score is on top.

```{r}
judgments |> 
 arrange(STAI_pre) 
```

#### For better readability, move the subject, STAI_pre and STAI_post columns to the first positions.

```{r}
judgments |> 
 arrange(STAI_pre) |> 
  relocate(subject, STAI_pre)
```

#### Check if the data set contains duplicated rows

::: {.callout-tip}
### Tip
Compare the number of rows in the raw input table with the number of rows 
in a de-duplicated table containing unique rows only. 
:::

```{r}
judgments |> 
  distinct()

judgments
```



### Exercise 2

#### Create a new column called `STAI_pre_category` 

It should contain "low", "normal" and "high" entries depending on the `STAI_pre` values:

  * if `STAI_pre` is less than `25` assign "low",
  
  * if `STAI_pre` is over `65` assign "high",
  
  * for all other values assign "normal".

#### Arrange the table by `STAI_pre` in a descending manner.

```{r}
# Write your answer here
```


### Display distinct values in `STAI_pre` and `STAI_pre_category`.

```{r}
# Write your answer here
```


##### Normalize the values in the REI group
Divide all entries in the REI questionnaire by 5, the maximal value.

```{r}
# Write your answer here
```


